name: Deploy to Staging

on:
  push:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "image_tag=latest" >> $GITHUB_OUTPUT
          fi
          echo "deployment_id=staging-$(date +%s)" >> $GITHUB_OUTPUT

      - name: Deploy to staging
        id: deploy
        run: |
          echo "🚀 Deploying to staging environment..."
          echo "Image tag: ${{ steps.vars.outputs.image_tag }}"
          echo "Deployment ID: ${{ steps.vars.outputs.deployment_id }}"
          
          # Simulate deployment (replace with actual deployment commands)
          echo "Pulling latest images..."
          echo "Updating staging environment..."
          echo "Running database migrations..."
          echo "Starting services..."
          
          # In a real environment, you would:
          # 1. SSH to staging server or use cloud deployment tools
          # 2. Pull the specified image tags
          # 3. Update docker-compose files with new image tags
          # 4. Run database migrations if needed
          # 5. Restart services with new images
          # 6. Run health checks
          
          sleep 10  # Simulate deployment time
          echo "✅ Staging deployment completed"

      - name: Run smoke tests
        run: |
          echo "🧪 Running smoke tests on staging..."
          
          # Wait for services to be ready
          timeout 300 bash -c 'until curl -f https://staging-api.newtube.app/health; do sleep 10; done' || {
            echo "❌ API health check failed"
            exit 1
          }
          
          timeout 300 bash -c 'until curl -f https://staging.newtube.app; do sleep 10; done' || {
            echo "❌ Frontend health check failed"
            exit 1
          }
          
          # Test critical endpoints
          curl -f https://staging-api.newtube.app/graphql -X POST \
            -H "Content-Type: application/json" \
            -d '{"query":"query { __schema { queryType { name } } }"}' || {
            echo "❌ GraphQL endpoint test failed"
            exit 1
          }
          
          echo "✅ All smoke tests passed"

      - name: Update deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Staging deployment successful"
            echo "🌐 Frontend: https://staging.newtube.app"
            echo "🔗 API: https://staging-api.newtube.app"
            echo "📊 Metrics: https://grafana.newtube.app/d/staging"
          else
            echo "❌ Staging deployment failed"
            echo "🔍 Check logs and run rollback if necessary"
          fi

      - name: Rollback on failure
        if: failure()
        run: |
          echo "🔄 Rolling back staging deployment..."
          
          # In a real environment, you would:
          # 1. Revert to previous known-good image tags
          # 2. Restart services
          # 3. Verify rollback was successful
          
          echo "📝 Rollback completed. Please investigate deployment failure."

  notify-staging:
    name: Notify Staging Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always()

    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
            echo "🎉 Staging deployment successful!"
            echo "Environment is ready for testing"
          else
            echo "❌ Staging deployment failed"
            echo "Please check logs and resolve issues"
          fi